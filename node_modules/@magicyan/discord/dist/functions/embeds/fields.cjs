'use strict';

const chars = require('../../constants/chars.cjs');

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class EmbedPlusFields {
  constructor(embed) {
    __publicField(this, "embed");
    this.embed = embed;
  }
  set fields(fields) {
    this.embed.setFields(fields);
  }
  get fields() {
    return this.embed.data.fields ?? [];
  }
  [Symbol.iterator]() {
    let pointer = 0;
    const fields = this.fields;
    return {
      next() {
        return {
          done: pointer >= fields.length,
          value: fields[pointer++] ?? null
        };
      }
    };
  }
  get length() {
    return this.fields.length;
  }
  get record() {
    return this.fields.reduce(
      (record, { name, value }) => Object.assign(record, { [name]: value }),
      {}
    );
  }
  get(query) {
    const isIndex = typeof query == "number";
    if (isIndex)
      return this.fields[query];
    return this.fields.find((f) => f.name === query);
  }
  find(predicate) {
    return this.fields.find(predicate);
  }
  push(...fields) {
    this.embed.addFields(fields.map(this.fieldFormat));
    return this;
  }
  set(...fields) {
    this.embed.setFields(fields.map(this.fieldFormat));
    return this;
  }
  insert(index, ...fields) {
    this.fields.splice(index, 0, ...fields.map(this.fieldFormat));
  }
  map(callback) {
    return this.toArray().map(callback);
  }
  update(predicate, field) {
    const index = this.getPredicateIndex(predicate);
    if (index == -1)
      return false;
    const embedField = this.get(index);
    if (!embedField)
      return false;
    this.embed.spliceFields(index, 1, Object.assign(embedField, field));
    return true;
  }
  delete(predicate) {
    const index = this.getPredicateIndex(predicate);
    if (index == -1)
      return false;
    const embedField = this.get(index);
    if (!embedField)
      return false;
    this.embed.spliceFields(index, 1);
    return true;
  }
  /**
   * Remove all fields
   */
  clear() {
    this.fields = [];
    return this;
  }
  toArray() {
    return Array.from(this);
  }
  getPredicateIndex(predicate) {
    switch (typeof predicate) {
      case "function":
        return this.fields.findIndex(predicate);
      case "string":
        return this.fields.findIndex((f) => f.name == predicate);
      case "number":
        return predicate;
      default:
        return -1;
    }
  }
  fieldFormat(field) {
    return Object.assign(
      { name: field.name ?? chars.chars.invisible, value: field.value ?? chars.chars.invisible },
      field.inline !== void 0 ? { inline: field.inline } : {}
    );
  }
}

exports.EmbedPlusFields = EmbedPlusFields;
