import { EmbedBuilder, AttachmentBuilder } from 'discord.js';
import { createEmbedAsset } from './assets.mjs';
import { EmbedPlusFields } from './fields.mjs';
import { createEmbedFooter } from './footer.mjs';
import { chars } from '../../constants/chars.mjs';
import { colors } from '../../constants/colors.mjs';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class EmbedPlusBuilder extends EmbedBuilder {
  constructor(data) {
    const { mergeFields = false, extends: extendsEmbed, ...embedData } = data;
    const extendsEmbedData = extendsEmbed ? "data" in extendsEmbed ? extendsEmbed.data : extendsEmbed : {};
    const { fields: extendsFields, ...extendsData } = extendsEmbedData;
    const fields = (mergeFields ? [extendsFields ?? [], data.fields ?? []].flat() : data.fields ?? extendsFields ?? []).map((field) => Object.assign(
      { name: field.name ?? chars.invisible, value: field.value ?? chars.invisible },
      field.inline !== void 0 ? { inline: field.inline } : {}
    ));
    const builderData = Object.assign({}, extendsData, embedData, { fields });
    if (builderData.url)
      builderData.url = builderData.url.toString();
    const { color, footer, image, thumbnail, timestamp } = embedData;
    if (footer)
      Object.assign(builderData, { footer: createEmbedFooter(footer) });
    if (image)
      Object.assign(builderData, { image: createEmbedAsset(image) });
    if (thumbnail)
      Object.assign(builderData, { thumbnail: createEmbedAsset(thumbnail) });
    const embed = new EmbedBuilder(builderData);
    if (timestamp)
      embed.setTimestamp(
        typeof timestamp === "string" ? new Date(timestamp) : timestamp
      );
    if (color)
      embed.setColor(color);
    super(embed.data);
    __publicField(this, "fields");
    this.fields = new EmbedPlusFields(this);
  }
  update(data) {
    const updated = createEmbed({ mergeFields: true, extends: this, ...data });
    Object.assign(this.data, updated.data);
    return this;
  }
  has(property) {
    return Boolean(this.data[property]);
  }
  toArray() {
    return Array.from([this]);
  }
  toString(space = 2) {
    return JSON.stringify(this, null, space);
  }
  toAttachment(data = { name: "embed.json" }, space = 2) {
    const buffer = Buffer.from(this.toString(space), "utf-8");
    return new AttachmentBuilder(buffer, data);
  }
  setColor(color) {
    if (color === null) {
      super.setColor(colors.embedbg);
    } else if (typeof color === "number") {
      this.update({ color });
    } else {
      super.setColor(color);
    }
    return this;
  }
  // public setBorderColor(color: EmbedPlusColorData | null): this {
  //     if (color === null){
  //         this.setColor(colors.embedbg as ColorResolvable);
  //     } else if (typeof color === "number"){
  //         this.update({ color });
  //     } else {
  //         this.setColor(color as ColorResolvable);
  //     }
  //     return this;
  // }
  setAsset(asset, source) {
    this.update({ [asset]: source });
    return this;
  }
  setElementImageURL(element, url) {
    switch (element) {
      case "thumbnail":
      case "image": {
        this.setAsset(element, url);
        break;
      }
      case "author": {
        const author = this.data.author;
        this.setAuthor({
          name: author?.name ?? chars.invisible,
          iconURL: url ?? void 0
        });
        break;
      }
      case "footer": {
        const footer = this.data.footer;
        this.setFooter({
          text: footer?.text ?? chars.invisible,
          iconURL: url ?? void 0
        });
        break;
      }
    }
    return this;
  }
}
function createEmbed(options) {
  const { array = false, from, fromIndex = 0, ...data } = options;
  const fromEmbeds = from ? "message" in from ? from.message.embeds : from.embeds : [];
  return array ? from && fromEmbeds.length > 0 ? fromEmbeds.map((embed) => new EmbedPlusBuilder({ extends: embed })) : [new EmbedPlusBuilder(data)] : from && fromEmbeds.length > 0 ? new EmbedPlusBuilder({ extends: fromEmbeds[fromIndex], ...data }) : new EmbedPlusBuilder(data);
}

export { EmbedPlusBuilder, createEmbed };
